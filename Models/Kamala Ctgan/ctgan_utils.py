import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def preprocess_data(data):
    """
    Preprocess the data for CTGAN, handling categorical columns appropriately.
    
    Args:
        data (pd.DataFrame): The dataset to preprocess
        
    Returns:
        tuple: (processed_data, categorical_columns)
    """
    # Detect and convert categorical columns
    categorical_columns = []
    for column in data.columns:
        # Check if column has few unique values (potential categorical)
        n_unique = data[column].nunique()
        n_total = len(data)
        
        # Handle non-numeric columns or numeric columns with few unique values
        if data[column].dtype == 'object' or (n_unique < min(20, n_total * 0.05) and data[column].dtype != 'float64'):
            # Convert column to category type
            try:
                data[column] = data[column].astype('category')
                categorical_columns.append(column)
                logger.info(f"Converted {column} to category type (has {n_unique} unique values)")
            except Exception as e:
                logger.warning(f"Could not convert {column} to category: {str(e)}")
    
    # Handle missing values
    for column in data.columns:
        if data[column].isnull().any():
            if column in categorical_columns:
                # Fill missing values in categorical columns with the most frequent value
                mode_value = data[column].mode()[0]
                data[column].fillna(mode_value, inplace=True)
                logger.info(f"Filled missing values in {column} with mode: {mode_value}")
            else:
                # Fill missing values in numerical columns with the mean
                mean_value = data[column].mean()
                data[column].fillna(mean_value, inplace=True)
                logger.info(f"Filled missing values in {column} with mean: {mean_value:.2f}")
    
    return data, categorical_columns

def visualize_comparison(real_data, synthetic_data, categorical_columns, dataset_name, output_file=None, target_column=None, n_features=5, figsize=(15, 20)):
    """
    Create visualizations comparing real and synthetic data distributions.
    
    Args:
        real_data (pd.DataFrame): Original data
        synthetic_data (pd.DataFrame): Synthetic data generated by CTGAN
        categorical_columns (list): List of categorical column names
        dataset_name (str): Name of the dataset for plot title
        output_file (str, optional): Path to save the visualization
        target_column (str, optional): Target column name for special handling
        n_features (int): Number of features to visualize
        figsize (tuple): Figure size as (width, height)
    """
    # Determine which features to visualize
    n_features = min(n_features, len(real_data.columns))
    
    # Prioritize categorical columns in visualization
    if categorical_columns:
        prioritized_columns = categorical_columns + [col for col in real_data.columns if col not in categorical_columns]
        features = prioritized_columns[:n_features]
    else:
        features = real_data.columns[:n_features]
    
    # Set up the figure
    fig, axes = plt.subplots(n_features, 2, figsize=figsize)
    fig.suptitle(f"Real vs Synthetic Data Distribution - {dataset_name}")
    
    if n_features == 1:
        axes = np.array([axes])
    
    # Plot comparisons for each feature
    for i, feature in enumerate(features):
        try:
            # First column: Distribution comparison
            if feature in categorical_columns:
                # For categorical features, use bar plots
                real_counts = real_data[feature].value_counts(normalize=True)
                synth_counts = synthetic_data[feature].value_counts(normalize=True)
                
                # Ensure both have the same categories
                all_categories = sorted(list(set(real_counts.index) | set(synth_counts.index)))
                real_counts_aligned = real_counts.reindex(all_categories, fill_value=0)
                synth_counts_aligned = synth_counts.reindex(all_categories, fill_value=0)
                
                comparison_df = pd.DataFrame({
                    'Real': real_counts_aligned,
                    'Synthetic': synth_counts_aligned
                })
                comparison_df.plot(kind='bar', ax=axes[i, 0])
            else:
                # For numerical features, use histograms with KDE
                sns.histplot(real_data[feature], kde=True, ax=axes[i, 0], color='blue', 
                             label='Real', stat="density", alpha=0.5)
                sns.histplot(synthetic_data[feature], kde=True, ax=axes[i, 0], color='red', 
                             label='Synthetic', stat="density", alpha=0.5)
            
            axes[i, 0].set_title(f"{feature} Distribution")
            axes[i, 0].legend()
            axes[i, 0].tick_params(axis='x', rotation=45)
            
            # Second column: Relationship with target (if applicable)
            if target_column and target_column in real_data.columns and target_column != feature:
                if feature in categorical_columns:
                    if target_column in categorical_columns:
                        # Categorical feature vs categorical target: Heatmap
                        real_crosstab = pd.crosstab(
                            real_data[feature], real_data[target_column], normalize='index'
                        )
                        sns.heatmap(real_crosstab, ax=axes[i, 1], cmap='Blues', 
                                    annot=True, fmt='.2f', cbar=False)
                        axes[i, 1].set_title(f"Real: {feature} vs {target_column}")
                    else:
                        # Categorical feature vs numerical target: Box plot
                        sns.boxplot(x=feature, y=target_column, data=real_data, ax=axes[i, 1], color='skyblue')
                        axes[i, 1].set_title(f"{feature} vs {target_column}")
                else:
                    if target_column in categorical_columns:
                        # Numerical feature vs categorical target: Violin plot
                        sns.violinplot(x=target_column, y=feature, data=real_data, ax=axes[i, 1], inner="box")
                        axes[i, 1].set_title(f"{feature} by {target_column}")
                    else:
                        # Numerical feature vs numerical target: Scatter plot
                        sns.scatterplot(data=real_data, x=feature, y=target_column, ax=axes[i, 1], 
                                         color='blue', label='Real', alpha=0.5)
                        sns.scatterplot(data=synthetic_data, x=feature, y=target_column, ax=axes[i, 1], 
                                         color='red', label='Synthetic', alpha=0.5)
                        axes[i, 1].set_title(f"{feature} vs {target_column}")
                        axes[i, 1].legend()
            else:
                # If no target relationship, show synthetic data distribution alone
                if feature in categorical_columns:
                    synth_counts = synthetic_data[feature].value_counts(normalize=True)
                    synth_counts.plot(kind='bar', ax=axes[i, 1], color='red')
                    axes[i, 1].set_title(f"Synthetic {feature} Distribution")
                else:
                    sns.histplot(synthetic_data[feature], kde=True, ax=axes[i, 1], 
                                 color='red', label='Synthetic', stat="density")
                    axes[i, 1].set_title(f"Synthetic {feature} Distribution")
            
            axes[i, 1].tick_params(axis='x', rotation=45)
        except Exception as e:
            logger.error(f"Error plotting visualizations for {feature}: {str(e)}")
            axes[i, 0].text(0.5, 0.5, f"Error: {str(e)}", ha='center', va='center')
            axes[i, 1].text(0.5, 0.5, f"Error: {str(e)}", ha='center', va='center')

    plt.tight_layout()
    
    # Save to file if specified
    if output_file:
        plt.savefig(output_file)
        logger.info(f"Saved visualization to {output_file}")
    
    plt.show()

def create_pairplot(data, target_column=None, title="Dataset Pairplot", output_file=None):
    """
    Create a pairplot of the dataset for exploring relationships between features.
    
    Args:
        data (pd.DataFrame): The dataset
        target_column (str, optional): Target column to use for coloring
        title (str): Plot title
        output_file (str, optional): Path to save the plot
    """
    plt.figure(figsize=(12, 10))
    
    if target_column and target_column in data.columns:
        g = sns.pairplot(data, hue=target_column)
    else:
        g = sns.pairplot(data)
    
    plt.suptitle(title, y=1.02)
    
    if output_file:
        plt.savefig(output_file)
        logger.info(f"Saved pairplot to {output_file}")
    
    plt.show()

def compare_target_distribution(real_data, synthetic_data, target_column, output_file=None):
    """
    Compare the distribution of the target variable between real and synthetic data.
    
    Args:
        real_data (pd.DataFrame): Original data
        synthetic_data (pd.DataFrame): Synthetic data
        target_column (str): Target column name
        output_file (str, optional): Path to save the plot
    """
    if target_column not in real_data.columns or target_column not in synthetic_data.columns:
        logger.warning(f"Target column '{target_column}' not found in data")
        return
    
    plt.figure(figsize=(10, 6))
    
    # Check if target is categorical or numerical
    if real_data[target_column].dtype.name == 'category' or synthetic_data[target_column].dtype.name == 'category':
        # Categorical target
        real_counts = real_data[target_column].value_counts(normalize=True)
        synth_counts = synthetic_data[target_column].value_counts(normalize=True)
        
        # Ensure both have the same categories
        all_categories = sorted(list(set(real_counts.index) | set(synth_counts.index)))
        real_counts_aligned = real_counts.reindex(all_categories, fill_value=0)
        synth_counts_aligned = synth_counts.reindex(all_categories, fill_value=0)
        
        comparison_df = pd.DataFrame({
            'Real': real_counts_aligned,
            'Synthetic': synth_counts_aligned
        })
        
        ax = comparison_df.plot(kind='bar')
        ax.set_title(f"{target_column} Distribution: Real vs Synthetic")
        ax.set_ylabel("Proportion")
        ax.set_xlabel(target_column)
    else:
        # Numerical target
        sns.kdeplot(real_data[target_column], label="Real", fill=True, alpha=0.3)
        sns.kdeplot(synthetic_data[target_column], label="Synthetic", fill=True, alpha=0.3)
        plt.title(f"{target_column} Distribution: Real vs Synthetic")
        plt.xlabel(target_column)
        plt.ylabel("Density")
    
    plt.legend()
    plt.tight_layout()
    
    if output_file:
        plt.savefig(output_file)
        logger.info(f"Saved target distribution comparison to {output_file}")
    
    plt.show()

def get_tstr_results(evaluation_results):
    """
    Extract and format TSTR results from evaluation metrics.
    
    Args:
        evaluation_results (dict): Results from evaluate_ctgan function
    
    Returns:
        pd.DataFrame: Formatted TSTR results
    """
    if "tstr_performance" not in evaluation_results:
        logger.warning("No TSTR performance metrics found in evaluation results")
        return None
    
    tstr_results = pd.DataFrame()
    
    for model, metrics in evaluation_results["tstr_performance"].items():
        model_results = {k: v for k, v in metrics.items() if k != "Error" and v is not None}
        model_row = pd.DataFrame(model_results, index=[model])
        tstr_results = pd.concat([tstr_results, model_row])
    
    return tstr_results